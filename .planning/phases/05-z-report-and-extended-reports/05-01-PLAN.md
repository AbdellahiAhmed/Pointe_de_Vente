---
phase: 05-z-report-and-extended-reports
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - back/src/Entity/Closing.php
  - back/migrations/Version20260217_ZReport.php
  - back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommand.php
  - back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandHandler.php
  - back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandHandlerInterface.php
  - back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandResult.php
  - back/src/Core/Dto/Common/Closing/ClosingDto.php
  - back/src/Controller/Api/Admin/ClosingController.php
autonomous: true
requirements:
  - ZRPT-01
  - ZRPT-02
  - ZRPT-03
  - ZRPT-04
  - ZRPT-05
  - ZRPT-06
  - ZRPT-08

must_haves:
  truths:
    - "POST /admin/closing/{id}/close assigns a sequential zReportNumber and persists a JSON snapshot that is never recalculated"
    - "GET /admin/closing/{id}/z-report-data returns the frozen snapshot JSON for a closed session"
    - "Closing a session that is already closed returns a 422 error"
    - "Only ROLE_MANAGER or ROLE_ADMIN can close a session (ClosingVoter::MANAGE)"
    - "The snapshot includes store header, sales summary (gross/discounts/net/returns/avg basket), payment breakdown with category, cash reconciliation (opening/cash received/added/withdrawn/expenses/expected/counted/variance), and denominations"
  artifacts:
    - path: "back/src/Entity/Closing.php"
      provides: "zReportNumber INT UNIQUE + zReportSnapshot JSON columns"
      contains: "zReportNumber"
    - path: "back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandHandler.php"
      provides: "Session close logic with snapshot aggregation"
      contains: "buildSnapshot"
    - path: "back/src/Controller/Api/Admin/ClosingController.php"
      provides: "POST close + GET z-report-data endpoints"
      contains: "closeSession"
  key_links:
    - from: "back/src/Controller/Api/Admin/ClosingController.php"
      to: "CloseSessionCommandHandlerInterface"
      via: "dependency injection"
      pattern: "CloseSessionCommandHandlerInterface"
    - from: "back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandHandler.php"
      to: "back/src/Entity/Closing.php"
      via: "setZReportSnapshot + setZReportNumber"
      pattern: "setZReportSnapshot"
---

<objective>
Create the backend foundation for the immutable Z-Report: add zReportNumber and zReportSnapshot columns to the Closing entity, build the CloseSessionCommand that aggregates all session data into a frozen JSON snapshot with a sequential number, and expose two new API endpoints (POST close, GET z-report-data).

Purpose: The Z-Report is the core regulatory document for end-of-day cash register closure. It must be generated once, stored as an immutable snapshot, and never recalculated from live data. This plan builds the entire data pipeline on the backend.

Output: Migration applied, CloseSessionCommand functional, two new endpoints operational.
</objective>

<execution_context>
@/Users/abdellahi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abdellahi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-z-report-and-extended-reports/05-RESEARCH.md

@back/src/Entity/Closing.php
@back/src/Controller/Api/Admin/ClosingController.php
@back/src/Controller/Api/Admin/ReportController.php
@back/src/Core/Closing/Command/UpdateClosingCommand/UpdateClosingCommand.php
@back/src/Core/Closing/Command/UpdateClosingCommand/UpdateClosingCommandHandler.php
@back/src/Core/Closing/Command/UpdateClosingCommand/UpdateClosingCommandResult.php
@back/src/Core/Closing/Command/UpdateClosingCommand/UpdateClosingCommandHandlerInterface.php
@back/src/Core/Dto/Common/Closing/ClosingDto.php
@back/src/Security/Voter/ClosingVoter.php
@back/src/Entity/Payment.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Closing entity migration and DTO update</name>
  <files>
    back/src/Entity/Closing.php
    back/migrations/Version20260217_ZReport.php
    back/src/Core/Dto/Common/Closing/ClosingDto.php
  </files>
  <action>
    1. Add two new properties to `back/src/Entity/Closing.php`:
       - `zReportNumber`: `@ORM\Column(type="integer", nullable=true, unique=true)` private $zReportNumber;
       - `zReportSnapshot`: `@ORM\Column(type="json", nullable=true)` private $zReportSnapshot;
       Add getters and setters following the existing pattern (getZReportNumber/setZReportNumber returning ?int, getZReportSnapshot/setZReportSnapshot returning ?array).

    2. Create a Doctrine migration file at `back/migrations/Version20260217_ZReport.php`. Use the existing migration naming pattern (namespace `DoctrineMigrations`). The `up()` method:
       ```sql
       ALTER TABLE closing ADD z_report_number INT DEFAULT NULL;
       ALTER TABLE closing ADD z_report_snapshot JSON DEFAULT NULL;
       CREATE UNIQUE INDEX uniq_closing_z_report_number ON closing (z_report_number);
       ```
       The `down()` method reverses these (DROP INDEX, then ALTER TABLE DROP COLUMN).

    3. Update `back/src/Core/Dto/Common/Closing/ClosingDto.php`:
       - Add private properties: `$zReportNumber` (?int) and `$zReportSnapshot` (?array)
       - Add getters and setters for both
       - In `createFromClosing()`, map:
         `$dto->zReportNumber = $closing->getZReportNumber();`
         `$dto->zReportSnapshot = $closing->getZReportSnapshot();`

    4. Run the migration inside Docker:
       ```bash
       docker exec dev-php-polymer php /var/www/html/polymer/bin/console doctrine:migrations:migrate --no-interaction
       ```
  </action>
  <verify>
    Run `docker exec dev-php-polymer php /var/www/html/polymer/bin/console doctrine:schema:validate` and confirm no schema diff for the closing table. Run `docker exec dev-php-polymer php /var/www/html/polymer/bin/console doctrine:schema:update --dump-sql` and check no pending SQL related to closing.
  </verify>
  <done>Closing entity has zReportNumber (INT UNIQUE nullable) and zReportSnapshot (JSON nullable) columns. ClosingDto serializes both new fields. Migration applied successfully.</done>
</task>

<task type="auto">
  <name>Task 2: CloseSessionCommand with snapshot aggregation and close/z-report-data endpoints</name>
  <files>
    back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommand.php
    back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandHandler.php
    back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandHandlerInterface.php
    back/src/Core/Closing/Command/CloseSessionCommand/CloseSessionCommandResult.php
    back/src/Controller/Api/Admin/ClosingController.php
  </files>
  <action>
    **A. Create CloseSessionCommand (4 files) following the exact pattern of UpdateClosingCommand:**

    **CloseSessionCommand.php**: Properties: `$id` (int), `$closedBy` (int - user ID), `$closingBalance` (?string - the counted cash), `$denominations` (?array - denomination counts). Standard getters/setters.

    **CloseSessionCommandResult.php**: Use traits `CqrsResultEntityNotFoundTrait` and `CqrsResultValidationTrait`. Add `$closing` property, getter/setter. Add a boolean `$alreadyClosed = false` with `isAlreadyClosed()` getter and a static `createAlreadyClosed()` factory.

    **CloseSessionCommandHandlerInterface.php**: Single method: `public function handle(CloseSessionCommand $command): CloseSessionCommandResult;`

    **CloseSessionCommandHandler.php**: Extends `EntityManager`, implements `CloseSessionCommandHandlerInterface`. Constructor injects `EntityManagerInterface` and `ValidatorInterface`.

    The `handle()` method does:
    1. Find closing by `$command->getId()`. Return notFound if null.
    2. If `$closing->getClosedAt() !== null`, return `CloseSessionCommandResult::createAlreadyClosed()`.
    3. **Assign sequential zReportNumber inside a transaction:**
       ```php
       $this->em->beginTransaction();
       try {
           $maxNumber = $this->em->createQuery(
               'SELECT MAX(c.zReportNumber) FROM App\Entity\Closing c'
           )->getSingleScalarResult() ?? 0;
           $closing->setZReportNumber((int)$maxNumber + 1);
       ```
    4. **Build the snapshot** by calling `$this->buildSnapshot($closing)` (private method described below).
    5. Set closing fields:
       - `$closing->setZReportSnapshot($snapshot);`
       - `$closing->setClosedAt(new \DateTimeImmutable());`
       - Set closedBy from `$command->getClosedBy()` (find User entity).
       - `$closing->setDateTo(new \DateTimeImmutable());`
       - If `$command->getClosingBalance() !== null`, set it.
       - If `$command->getDenominations() !== null`, set it.
    6. Validate, flush, commit transaction. On exception, rollback and rethrow.

    **The `buildSnapshot()` private method** builds the full JSON structure. It runs DQL queries scoped to `$closing->getDateFrom()`, `$closing->getDateTo()` (use `new \DateTimeImmutable()` as dateTo since session is being closed now), and `$closing->getTerminal()`. **CRITICAL**: Every query MUST include `o.isDeleted = false` AND `(o.isSuspended != true OR o.isSuspended IS NULL)`.

    Snapshot shape (matching research doc):
    ```php
    return [
        'zReportNumber' => $closing->getZReportNumber(),
        'generatedAt' => (new \DateTimeImmutable())->format(\DateTime::ATOM),
        'store' => [
            'name' => $closing->getStore()->getName(),
            'location' => $closing->getStore()->getLocation() ?? '',
        ],
        'terminal' => ['code' => $closing->getTerminal()->getCode()],
        'openedBy' => $closing->getOpenedBy()?->getDisplayName() ?? '',
        'closedBy' => $closing->getClosedBy()?->getDisplayName() ?? '',
        'dateFrom' => $closing->getDateFrom()?->format(\DateTime::ATOM),
        'dateTo' => $closing->getDateTo()?->format(\DateTime::ATOM),
        'sales' => $this->aggregateSales($closing),
        'paymentBreakdown' => $this->aggregatePayments($closing),
        'cashReconciliation' => $this->buildCashReconciliation($closing),
        'denominations' => $closing->getDenominations() ?? [],
    ];
    ```

    **`aggregateSales()`**: Two DQL queries (copy pattern from ReportController /sales):
    - Query 1: COUNT orders (total, completed, returned) from Order scoped by dateFrom/dateTo/terminal.
    - Query 2: SUM revenue (gross, discounts) from OrderProduct JOINed to Order, scoped same way, excluding isReturned.
    - Compute netRevenue = gross - discounts, avgBasket = netRevenue / completedOrders.
    - Return associative array: totalOrders, completedOrders, returnedOrders, grossRevenue, totalDiscounts, netRevenue, averageBasket.

    **`aggregatePayments()`**: DQL query (copy pattern from ReportController payment breakdown):
    - SELECT p.name, p.category, SUM(opay.total) FROM OrderPayment opay JOIN opay.type p JOIN opay.order o WHERE scoped + filters GROUP BY p.id, p.name, p.category.
    - Return array of `['name' => ..., 'category' => ..., 'amount' => ...]`.

    **`buildCashReconciliation()`**: Uses Closing entity fields + computed cash payment total:
    ```php
    $openingBalance = (float) ($closing->getOpeningBalance() ?? 0);
    $cashReceived = // sum of payments where category='cash' from aggregatePayments
    $cashAdded = (float) ($closing->getCashAdded() ?? 0);
    $cashWithdrawn = (float) ($closing->getCashWithdrawn() ?? 0);
    $expenses = (float) ($closing->getExpenses() ?? 0);
    $expectedCash = $openingBalance + $cashReceived + $cashAdded - $cashWithdrawn - $expenses;
    $countedCash = (float) ($closing->getClosingBalance() ?? 0);
    $variance = $countedCash - $expectedCash;
    ```
    Return all these as an associative array.

    **B. Add two new endpoints to ClosingController.php:**

    1. `POST /{id}/close` (name: "close"):
       - `$this->denyAccessUnlessGranted(ClosingVoter::MANAGE);`
       - Parse JSON body for `closingBalance`, `denominations` fields.
       - Create CloseSessionCommand, set id from route param, closedBy from `$this->getUser()->getId()`, closingBalance, denominations.
       - Call handler->handle().
       - If notFound, return 404. If alreadyClosed, return `$responseFactory->validationError('Session already closed')`.
       - Return `$responseFactory->json(SelectClosingResponseDto::createFromClosing($result->getClosing()))`.
       - IMPORTANT: Place this route BEFORE the `/{id}` GET route in the controller to avoid route conflict (Symfony matches routes in order; `/{id}` would catch "close" as an id). Use `requirements={"id"="\d+"}` on the route annotation to disambiguate.

    2. `GET /{id}/z-report-data` (name: "z_report_data"):
       - `$this->denyAccessUnlessGranted(ClosingVoter::MANAGE);`
       - Find Closing by id. If null, return 404.
       - If `$closing->getZReportSnapshot() === null`, return `$responseFactory->validationError('Z-Report not generated yet')`.
       - Return `$responseFactory->json($closing->getZReportSnapshot())`.
       - Also add `requirements={"id"="\d+"}` on this route.
  </action>
  <verify>
    1. Run `docker exec dev-php-polymer php /var/www/html/polymer/bin/console cache:clear` to verify no Symfony DI compilation errors.
    2. Verify the CloseSessionCommandHandlerInterface is properly autowired by checking: `docker exec dev-php-polymer php /var/www/html/polymer/bin/console debug:autowiring CloseSession` (should show the handler).
    3. Verify routes are registered: `docker exec dev-php-polymer php /var/www/html/polymer/bin/console debug:router | grep close` should show the new close route.
  </verify>
  <done>CloseSessionCommand handler aggregates all session data (sales, payments, cash reconciliation, denominations) into a frozen JSON snapshot. POST /admin/closing/{id}/close assigns sequential zReportNumber and persists immutable snapshot. GET /admin/closing/{id}/z-report-data returns the frozen snapshot. Both endpoints gated by ClosingVoter::MANAGE (ROLE_MANAGER+). Already-closed sessions rejected with 422.</done>
</task>

</tasks>

<verification>
1. Closing entity has zReportNumber and zReportSnapshot columns in DB
2. POST /admin/closing/{id}/close returns snapshot with sequential number
3. GET /admin/closing/{id}/z-report-data returns the stored snapshot JSON
4. Calling close twice on same session returns error
5. Non-MANAGER users cannot access close endpoint
6. Snapshot includes all required sections: store header, sales summary, payment breakdown, cash reconciliation, denominations
</verification>

<success_criteria>
- zReportNumber is sequential and unique across all closings
- zReportSnapshot JSON is persisted once at close time and never recalculated
- The snapshot contains complete data for rendering a Z-Report PDF: store info, terminal, date range, sales summary (gross/discounts/net/returns/avg basket), payment breakdown with category, cash reconciliation (opening/received/added/withdrawn/expenses/expected/counted/variance), denominations
- Both new endpoints respond correctly behind ClosingVoter::MANAGE
</success_criteria>

<output>
After completion, create `.planning/phases/05-z-report-and-extended-reports/05-01-SUMMARY.md`
</output>

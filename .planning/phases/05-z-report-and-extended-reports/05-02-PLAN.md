---
phase: 05-z-report-and-extended-reports
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - back/src/Controller/Api/Admin/ReportController.php
autonomous: true
requirements:
  - RAPT-01
  - RAPT-02
  - RAPT-03
  - RAPT-04
  - RAPT-05

must_haves:
  truths:
    - "GET /admin/report/vendor returns per-vendeur breakdown: revenue, ticket count, average basket"
    - "GET /admin/report/category returns per-category breakdown: revenue, cost, profit, margin %"
    - "GET /admin/report/daily now returns top vendors, and J-1 (yesterday) comparison data"
    - "GET /admin/report/profit now returns per-product margin % in topProducts"
    - "GET /admin/report/sales now returns average basket metric"
  artifacts:
    - path: "back/src/Controller/Api/Admin/ReportController.php"
      provides: "vendor(), category() new endpoints + enhanced daily(), profit(), sales()"
      contains: "vendor"
  key_links:
    - from: "back/src/Controller/Api/Admin/ReportController.php"
      to: "OrderProduct, Order, User, Category entities"
      via: "DQL GROUP BY queries"
      pattern: "groupBy"
---

<objective>
Add two new report endpoints (vendor and category) and enhance three existing endpoints (daily, profit, sales) in ReportController to provide the detailed analytics required by RAPT-01 through RAPT-05.

Purpose: The extended reports give the manager actionable breakdowns of performance by vendeur, product category, and time comparison (J-1), enabling informed business decisions beyond the basic sales/profit summaries.

Output: Five API endpoints updated or created in ReportController.php, all following existing DQL patterns and RBAC gating.
</objective>

<execution_context>
@/Users/abdellahi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abdellahi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-z-report-and-extended-reports/05-RESEARCH.md

@back/src/Controller/Api/Admin/ReportController.php
@back/src/Entity/Order.php
@back/src/Entity/OrderProduct.php
@back/src/Entity/OrderPayment.php
@back/src/Entity/Payment.php
@back/src/Entity/Product.php
@back/src/Security/Voter/ReportVoter.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add vendor and category report endpoints</name>
  <files>back/src/Controller/Api/Admin/ReportController.php</files>
  <action>
    Add two new methods to `ReportController.php`. Both use `$this->denyAccessUnlessGranted(ReportVoter::VIEW)` and accept `dateFrom`, `dateTo`, `store` query parameters following the exact same pattern as the existing `sales()` method.

    **CRITICAL for ALL queries**: Always include these filters on Order:
    - `o.isDeleted = false`
    - `o.isSuspended != true OR o.isSuspended IS NULL`
    - `o.isReturned = false` (for revenue queries)

    **1. `vendor()` method** - Route: `@Route("/vendor", name="vendor", methods={"GET"})`

    Query 1 - Vendor performance:
    ```php
    $qb->select(
        'u.id as vendorId',
        'u.displayName as vendorName',
        'COUNT(DISTINCT o.id) as totalOrders',
        'COALESCE(SUM(op.price * op.quantity), 0) as grossRevenue',
        'COALESCE(SUM(op.discount), 0) as totalDiscounts'
    )
    ->from(OrderProduct::class, 'op')
    ->join('op.order', 'o')
    ->join('o.user', 'u')
    ->where('DATE(o.createdAt) >= :dateFrom')
    ->andWhere('DATE(o.createdAt) <= :dateTo')
    ->andWhere('o.isDeleted = false')
    ->andWhere('o.isReturned = false')
    ->andWhere('o.isSuspended != true OR o.isSuspended IS NULL')
    ->groupBy('u.id', 'u.displayName')
    ->orderBy('grossRevenue', 'DESC');
    ```
    Add store filter if provided.

    For each vendor row, compute:
    - `netRevenue = grossRevenue - totalDiscounts`
    - `averageBasket = totalOrders > 0 ? round(netRevenue / totalOrders, 2) : 0`

    Return JSON:
    ```json
    {
      "dateFrom": "...",
      "dateTo": "...",
      "vendors": [
        {
          "vendorId": 1,
          "vendorName": "Ahmed",
          "totalOrders": 15,
          "grossRevenue": 50000.00,
          "totalDiscounts": 2000.00,
          "netRevenue": 48000.00,
          "averageBasket": 3200.00
        }
      ]
    }
    ```

    **2. `category()` method** - Route: `@Route("/category", name="category", methods={"GET"})`

    Query - Category breakdown (note: Product.categories is ManyToMany, use full attribution per category):
    ```php
    $qb->select(
        'cat.id as categoryId',
        'cat.name as categoryName',
        'COUNT(DISTINCT o.id) as totalOrders',
        'COALESCE(SUM(op.price * op.quantity), 0) as grossRevenue',
        'COALESCE(SUM(op.discount), 0) as totalDiscounts',
        'COALESCE(SUM(COALESCE(op.costAtSale, 0) * op.quantity), 0) as totalCost'
    )
    ->from(OrderProduct::class, 'op')
    ->join('op.order', 'o')
    ->join('op.product', 'prod')
    ->join('prod.categories', 'cat')
    ->where('DATE(o.createdAt) >= :dateFrom')
    ->andWhere('DATE(o.createdAt) <= :dateTo')
    ->andWhere('o.isDeleted = false')
    ->andWhere('o.isReturned = false')
    ->andWhere('o.isSuspended != true OR o.isSuspended IS NULL')
    ->groupBy('cat.id', 'cat.name')
    ->orderBy('grossRevenue', 'DESC');
    ```
    Add store filter if provided.

    For each category row, compute:
    - `netRevenue = grossRevenue - totalDiscounts`
    - `grossProfit = netRevenue - totalCost`
    - `profitMargin = netRevenue > 0 ? round((grossProfit / netRevenue) * 100, 2) : 0`

    Return JSON:
    ```json
    {
      "dateFrom": "...",
      "dateTo": "...",
      "categories": [
        {
          "categoryId": 1,
          "categoryName": "Boissons",
          "totalOrders": 30,
          "grossRevenue": 80000.00,
          "totalDiscounts": 1000.00,
          "netRevenue": 79000.00,
          "totalCost": 40000.00,
          "grossProfit": 39000.00,
          "profitMargin": 49.37
        }
      ]
    }
    ```

    Add the `use App\Entity\User;` import at the top of ReportController if not already present. The `Category` entity is joined through `prod.categories`, so no direct import needed (Doctrine resolves through the relationship).
  </action>
  <verify>
    Run `docker exec dev-php-polymer php /var/www/html/polymer/bin/console cache:clear` to verify no compilation errors.
    Run `docker exec dev-php-polymer php /var/www/html/polymer/bin/console debug:router | grep vendor` to confirm the vendor route is registered.
    Run `docker exec dev-php-polymer php /var/www/html/polymer/bin/console debug:router | grep category` to confirm the category route is registered.
  </verify>
  <done>GET /admin/report/vendor returns per-vendeur breakdown (revenue, orders, avg basket). GET /admin/report/category returns per-category breakdown (revenue, cost, profit, margin %). Both gated by ReportVoter::VIEW.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance daily, profit, and sales endpoints</name>
  <files>back/src/Controller/Api/Admin/ReportController.php</files>
  <action>
    Enhance three existing methods in ReportController.php:

    **1. Enhance `daily()` method (RAPT-03):**

    a) Add **top vendors** query after the existing top products query:
    ```php
    $qb5 = $this->em->createQueryBuilder();
    $qb5->select(
        'u.displayName as vendorName',
        'COUNT(DISTINCT o.id) as totalOrders',
        'COALESCE(SUM(op.price * op.quantity), 0) as revenue'
    )
    ->from(OrderProduct::class, 'op')
    ->join('op.order', 'o')
    ->join('o.user', 'u')
    ->where('DATE(o.createdAt) = :date')
    ->andWhere('o.isDeleted = false')
    ->andWhere('o.isReturned = false')
    ->andWhere('o.isSuspended != true OR o.isSuspended IS NULL')
    ->groupBy('u.id', 'u.displayName')
    ->orderBy('revenue', 'DESC')
    ->setMaxResults(5)
    ->setParameter('date', $date);
    ```
    Add store filter if provided. Add `$topVendors` to the response JSON as `'topVendors' => $topVendors`.

    b) Add **J-1 (yesterday) comparison**. Compute yesterday's date:
    ```php
    $yesterday = (new \DateTime($date))->modify('-1 day')->format('Y-m-d');
    ```
    Run a simplified revenue query for yesterday (same structure as qb2 but with `DATE(o.createdAt) = :yesterday`). Extract yesterday's `grossRevenue`, `netRevenue`, `totalOrders`.

    Add to response:
    ```php
    'yesterday' => [
        'date' => $yesterday,
        'grossRevenue' => round((float) $yesterdayRevenue['grossRevenue'], 2),
        'netRevenue' => round((float) $yesterdayRevenue['grossRevenue'] - (float) $yesterdayRevenue['totalDiscounts'], 2),
        'totalOrders' => (int) $yesterdayOrders['totalOrders'],
    ],
    ```
    Also add `'averageBasket' => $avgBasket` to the existing response (compute same as in sales(): `$netRevenue / max($completedOrders, 1)`). Compute `$completedOrders = (int)$orderSummary['totalOrders'] - (int)$orderSummary['returnedOrders']`.

    **2. Enhance `profit()` method (RAPT-02):**

    In the existing `topProducts` query ($qb2), add a computed `margin` field to each product row. After fetching `$topProducts`, loop and add margin:
    ```php
    $topProducts = array_map(function ($row) {
        $revenue = (float) $row['revenue'];
        $cost = (float) $row['cost'];
        $netProductRevenue = $revenue; // per-product, no discount split available
        $row['margin'] = $netProductRevenue > 0
            ? round((($netProductRevenue - $cost) / $netProductRevenue) * 100, 2)
            : 0;
        return $row;
    }, $topProducts);
    ```
    This adds a `margin` percentage field to each product in the response, satisfying RAPT-02 (margin per product).

    **3. Enhance `sales()` method (RAPT-01):**

    The sales endpoint already returns `averageBasket` in the response (confirmed in existing code). Verify it is present. No code change needed if it already exists. The `averageBasket` field satisfies the RAPT-01 "panier moyen" requirement. The existing payment breakdown and the new category/vendor endpoints (from Task 1) collectively satisfy the rest of RAPT-01.

    If for any reason `averageBasket` is missing from the response, add it (but per codebase reading it is already there at line 115 of the current ReportController).
  </action>
  <verify>
    Run `docker exec dev-php-polymer php /var/www/html/polymer/bin/console cache:clear` to verify no compilation errors.
    Manually verify that the `daily()` method response includes `topVendors`, `yesterday`, and `averageBasket` keys in its return array.
    Verify that `profit()` topProducts rows include `margin` key.
  </verify>
  <done>Daily report enhanced with top vendors (top 5 by revenue), J-1 comparison (yesterday's revenue + orders), and average basket. Profit report's topProducts includes margin % per product. Sales report confirmed to include averageBasket.</done>
</task>

</tasks>

<verification>
1. GET /admin/report/vendor?dateFrom=2026-02-17&dateTo=2026-02-17 returns vendors array with vendorName, totalOrders, grossRevenue, netRevenue, averageBasket
2. GET /admin/report/category?dateFrom=2026-02-17&dateTo=2026-02-17 returns categories array with categoryName, grossRevenue, totalCost, grossProfit, profitMargin
3. GET /admin/report/daily?date=2026-02-17 returns topVendors, yesterday comparison, and averageBasket
4. GET /admin/report/profit?dateFrom=2026-02-17&dateTo=2026-02-17 returns topProducts with margin field
5. All endpoints gated by ReportVoter::VIEW
6. All queries exclude deleted, suspended, and returned orders
</verification>

<success_criteria>
- Two new endpoints (/vendor, /category) return structured analytics
- Daily report includes top vendors, J-1 comparison, and average basket
- Profit report shows margin % per product using costAtSale (not live cost)
- Category report uses full attribution (products in multiple categories counted in each)
- All queries consistently apply isDeleted, isSuspended, isReturned filters
</success_criteria>

<output>
After completion, create `.planning/phases/05-z-report-and-extended-reports/05-02-SUMMARY.md`
</output>

---
phase: 01-rbac-and-security
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - front/src/duck/auth/hooks/useHasRole.ts
  - front/src/app-common/components/auth/RequireRole.tsx
  - front/src/app-admin/app.tsx
  - front/src/app-admin/containers/layout/sidebar.tsx
  - front/src/app-frontend/components/settings/users/create.user.tsx
  - front/src/app-frontend/components/settings/items/export.items.tsx
autonomous: true

must_haves:
  truths:
    - "A VENDEUR logged into admin sees only Dashboard in the sidebar - no Reports, no Users links"
    - "A VENDEUR navigating to /reports/sales in the browser is redirected to /dashboard"
    - "A MANAGER sees Dashboard and Reports links but not Users link in the sidebar"
    - "A MANAGER navigating to /users in the browser is redirected to /dashboard"
    - "An ADMIN sees all sidebar links including Users"
    - "The create/edit user form offers ROLE_VENDEUR, ROLE_MANAGER, ROLE_ADMIN as role options"
    - "Product export no longer exposes JWT in the URL"
  artifacts:
    - path: "front/src/duck/auth/hooks/useHasRole.ts"
      provides: "Role checking hook with hierarchy resolution"
      exports: ["useHasRole"]
      min_lines: 15
    - path: "front/src/app-common/components/auth/RequireRole.tsx"
      provides: "Route guard component that redirects unauthorized users"
      exports: ["RequireRole"]
      min_lines: 15
    - path: "front/src/app-admin/app.tsx"
      provides: "Route definitions wrapped with RequireRole for role-gated pages"
      contains: "RequireRole"
    - path: "front/src/app-admin/containers/layout/sidebar.tsx"
      provides: "Sidebar nav items conditionally rendered by role"
      contains: "useHasRole"
    - path: "front/src/app-frontend/components/settings/items/export.items.tsx"
      provides: "Secure product export using fetch+Blob instead of JWT in URL"
      contains: "request("
  key_links:
    - from: "front/src/app-admin/app.tsx"
      to: "front/src/app-common/components/auth/RequireRole.tsx"
      via: "import and wrap routes"
      pattern: "RequireRole.*role=.*ROLE_"
    - from: "front/src/app-common/components/auth/RequireRole.tsx"
      to: "front/src/duck/auth/hooks/useHasRole.ts"
      via: "useHasRole hook call"
      pattern: "useHasRole"
    - from: "front/src/app-admin/containers/layout/sidebar.tsx"
      to: "front/src/duck/auth/hooks/useHasRole.ts"
      via: "conditional rendering of nav items"
      pattern: "useHasRole"
---

<objective>
Frontend RBAC: Create useHasRole hook and RequireRole component, add role-based route guards to admin app, conditionally render sidebar items by role, update user form role options to 3-role system, and fix the JWT-in-URL security vulnerability in product export.

Purpose: Ensure unauthorized users cannot see or navigate to restricted pages even if the backend would block the API call. Fixes a security hole where JWT tokens are exposed in server logs via URL parameters.
Output: useHasRole hook, RequireRole component, role-gated routes and sidebar, updated role dropdown, secure export.
</objective>

<execution_context>
@/Users/abdellahi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abdellahi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-rbac-and-security/01-RESEARCH.md
@.planning/phases/01-rbac-and-security/01-01-SUMMARY.md

@front/src/duck/auth/auth.selector.ts
@front/src/duck/auth/model/authorized.user.ts
@front/src/api/model/user.ts
@front/src/app-admin/app.tsx
@front/src/app-admin/containers/layout/sidebar.tsx
@front/src/app-admin/routes/frontend.routes.ts
@front/src/app-frontend/components/settings/users/create.user.tsx
@front/src/app-frontend/components/settings/items/export.items.tsx
@front/src/api/request/request.ts
@front/src/api/routing/routes/backend.app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: useHasRole hook + RequireRole component + route guards + sidebar</name>
  <files>
    front/src/duck/auth/hooks/useHasRole.ts
    front/src/app-common/components/auth/RequireRole.tsx
    front/src/app-admin/app.tsx
    front/src/app-admin/containers/layout/sidebar.tsx
  </files>
  <action>
    **Satisfies: RBAC-02, RBAC-03, RBAC-04, RBAC-05 (frontend enforcement)**

    **1. Create `front/src/duck/auth/hooks/useHasRole.ts`:**

    ```typescript
    import { useSelector } from 'react-redux';
    import { getAuthorizedUser } from '../auth.selector';

    const ROLE_HIERARCHY: Record<string, string[]> = {
      ROLE_ADMIN:   ['ROLE_MANAGER', 'ROLE_VENDEUR'],
      ROLE_MANAGER: ['ROLE_VENDEUR'],
      ROLE_VENDEUR: [],
    };

    function hasRoleWithHierarchy(userRoles: string[], requiredRole: string): boolean {
      for (const role of userRoles) {
        if (role === requiredRole) return true;
        const inherited = ROLE_HIERARCHY[role] ?? [];
        if (inherited.includes(requiredRole)) return true;
      }
      return false;
    }

    export function useHasRole(requiredRole: string): boolean {
      const user = useSelector(getAuthorizedUser);
      if (!user) return false;
      return hasRoleWithHierarchy(user.roles, requiredRole);
    }
    ```

    The `getAuthorizedUser` selector already exists at `front/src/duck/auth/auth.selector.ts` and returns an `AuthorizedUser` (which extends `User`) with `roles: string[]`. This hook mirrors the backend hierarchy exactly.

    **2. Create `front/src/app-common/components/auth/` directory and `RequireRole.tsx`:**

    ```tsx
    import { Navigate, useLocation } from 'react-router-dom';
    import { useHasRole } from '../../../duck/auth/hooks/useHasRole';

    interface RequireRoleProps {
      role: string;
      children: JSX.Element;
      redirectTo?: string;
    }

    export const RequireRole = ({ role, children, redirectTo = '/dashboard' }: RequireRoleProps) => {
      const location = useLocation();
      const hasRole = useHasRole(role);

      if (!hasRole) {
        return <Navigate to={redirectTo} state={{ from: location }} replace />;
      }

      return children;
    };
    ```

    NOTE: `redirectTo` defaults to `/dashboard` (not `/login`). An unauthorized but authenticated user should go to dashboard, not login. The existing `RequireAuth` already handles unauthenticated users.

    **3. Update `front/src/app-admin/app.tsx`:**

    Add import at the top:
    ```typescript
    import { RequireRole } from '../app-common/components/auth/RequireRole';
    ```

    Wrap role-restricted routes with `RequireRole` INSIDE the existing `RequireAuth`. The nesting order matters: `RequireAuth` checks if logged in, then `RequireRole` checks if authorized.

    Change these routes:

    ```tsx
    {/* Users routes — ADMIN only */}
    <Route path={USERS} element={<RequireAuth><RequireRole role="ROLE_ADMIN"><Users/></RequireRole></RequireAuth>}/>
    <Route path={USERS_CREATE} element={<RequireAuth><RequireRole role="ROLE_ADMIN"><Users/></RequireRole></RequireAuth>}/>
    <Route path={USERS_EDIT} element={<RequireAuth><RequireRole role="ROLE_ADMIN"><Users/></RequireRole></RequireAuth>}/>

    {/* Reports routes — MANAGER+ */}
    <Route path={REPORTS_SALES} element={<RequireAuth><RequireRole role="ROLE_MANAGER"><SalesReport/></RequireRole></RequireAuth>}/>
    <Route path={REPORTS_PROFIT} element={<RequireAuth><RequireRole role="ROLE_MANAGER"><ProfitReport/></RequireRole></RequireAuth>}/>
    <Route path={REPORTS_DAILY} element={<RequireAuth><RequireRole role="ROLE_MANAGER"><DailyReport/></RequireRole></RequireAuth>}/>
    ```

    Leave `DASHBOARD` and `PROFILE` routes as-is (all authenticated users can access these).

    **4. Update `front/src/app-admin/containers/layout/sidebar.tsx`:**

    Add import at the top:
    ```typescript
    import { useHasRole } from '../../../duck/auth/hooks/useHasRole';
    import { USERS } from '../../routes/frontend.routes';
    ```

    Inside the `Sidebar` component, add role checks:
    ```typescript
    const isManager = useHasRole('ROLE_MANAGER');
    const isAdmin = useHasRole('ROLE_ADMIN');
    ```

    Wrap the Reports section (the `<li className="nav-heading">` for Reports AND the three report nav items) in a conditional:
    ```tsx
    {isManager && (
      <>
        <li className="nav-heading">{t('Reports')}</li>
        {/* ...existing report links... */}
      </>
    )}
    ```

    Add a Users section for ADMIN only, AFTER the Reports section:
    ```tsx
    {isAdmin && (
      <>
        <li className="nav-heading">{t('Administration')}</li>
        <li className="nav-item">
          <Link className={classNames(
            "nav-link", location.pathname === USERS ? 'active' : 'collapsed'
          )} to={USERS}>
            <i className="bi bi-people"></i>
            <span>{t('Users')}</span>
          </Link>
        </li>
      </>
    )}
    ```

    The Dashboard link remains visible to all authenticated users.
  </action>
  <verify>
    1. Verify all files compile: `cd /Users/abdellahi/Documents/POS/Pointe_de_Vente/front && npx tsc --noEmit` (or just check the specific files parse — if tsc takes too long due to full project, verify with `npx tsc --noEmit --target esnext --moduleResolution node --jsx react-jsx --esModuleInterop front/src/duck/auth/hooks/useHasRole.ts`). Alternatively, run `npx vite build --mode development 2>&1 | head -20` to check for compile errors.
    2. Grep for RequireRole usage: `grep -rn "RequireRole" front/src/app-admin/app.tsx` — should show 6 occurrences (3 user routes + 3 report routes).
    3. Grep for useHasRole usage: `grep -rn "useHasRole" front/src/app-admin/containers/layout/sidebar.tsx` — should show the import and 2 hook calls.
    4. Verify RequireRole file exists: `ls front/src/app-common/components/auth/RequireRole.tsx`.
    5. Verify useHasRole file exists: `ls front/src/duck/auth/hooks/useHasRole.ts`.
  </verify>
  <done>
    - useHasRole hook exists and mirrors backend ROLE_ADMIN > ROLE_MANAGER > ROLE_VENDEUR hierarchy
    - RequireRole component redirects unauthorized users to /dashboard
    - User routes (/users, /users/create, /users/edit/:id) are wrapped with RequireRole role="ROLE_ADMIN"
    - Report routes (/reports/sales, /reports/profit, /reports/daily) are wrapped with RequireRole role="ROLE_MANAGER"
    - Dashboard and Profile routes remain accessible to all authenticated users
    - Sidebar hides Reports section from VENDEUR users
    - Sidebar hides Users/Administration section from non-ADMIN users
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update user role options + fix JWT-in-URL export security hole</name>
  <files>
    front/src/app-frontend/components/settings/users/create.user.tsx
    front/src/app-frontend/components/settings/items/export.items.tsx
  </files>
  <action>
    **Satisfies: RBAC-01 (role assignment), RBAC-05 (security fix from research critical pitfalls)**

    **1. Update role dropdown in `front/src/app-frontend/components/settings/users/create.user.tsx`:**

    Find the ReactSelect `options` array for the "roles" field (around line 199-205). Currently it has:
    ```typescript
    options={[{
      label: 'ROLE_USER',
      value: 'ROLE_USER'
    }, {
      label: 'ROLE_ADMIN',
      value: 'ROLE_ADMIN'
    }]}
    ```

    Replace with the 3-role system:
    ```typescript
    options={[{
      label: t('Vendeur (Cashier)'),
      value: 'ROLE_VENDEUR'
    }, {
      label: t('Manager'),
      value: 'ROLE_MANAGER'
    }, {
      label: t('Admin'),
      value: 'ROLE_ADMIN'
    }]}
    ```

    Use `t()` for the labels so they are translatable. The `value` must be the exact Symfony role string. Remove `isMulti` prop from the ReactSelect — a user should have exactly ONE primary role (the hierarchy handles inheritance). Change it to single-select.

    Wait — looking at the existing code more carefully, the form uses `isMulti` and the `createUser` function maps `values.roles` as an array: `values.roles.map((item: ReactSelectOptionProps) => item.value)`. The backend `User::setRoles()` accepts an array. With single-select, `values.roles` would be a single object, not an array.

    Two approaches:
    - **Option A**: Keep `isMulti` but update options to the 3 new roles. Admin can still multi-select if needed.
    - **Option B**: Remove `isMulti`, and in the submit handler, wrap the single value in an array.

    **Go with Option A** (keep `isMulti`). It's simpler, doesn't change form logic, and the backend already handles arrays. The user just selects one role in practice, but the flexibility doesn't hurt. The key change is the OPTIONS, not the select behavior.

    So the only change is replacing the options array content. Remove ROLE_USER and ROLE_ADMIN options, replace with ROLE_VENDEUR, ROLE_MANAGER, ROLE_ADMIN:

    ```typescript
    options={[{
      label: t('Vendeur'),
      value: 'ROLE_VENDEUR'
    }, {
      label: t('Manager'),
      value: 'ROLE_MANAGER'
    }, {
      label: t('Admin'),
      value: 'ROLE_ADMIN'
    }]}
    ```

    **2. Fix JWT-in-URL in `front/src/app-frontend/components/settings/items/export.items.tsx`:**

    Current code exposes JWT in the URL query string (visible in server logs, browser history, referrer headers):
    ```typescript
    const url = new URL(PRODUCT_DOWNLOAD);
    url.search = QueryString.stringify({
      bearer: Cookies.get("JWT"),
    });
    window.open(url.toString(), "_blank");
    ```

    Replace with a secure fetch + Blob download pattern. The `request` function from `../../../../api/request/request` already adds the Authorization header automatically from the JWT cookie.

    Replace the entire `onClick` function body:
    ```typescript
    const onClick = async () => {
      const { request } = await import('../../../../api/request/request');
      const response = await request(PRODUCT_DOWNLOAD);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'products.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };
    ```

    Actually, to keep it consistent with the rest of the codebase, use a static import instead of dynamic:

    Replace the import section. Remove these imports (no longer needed):
    ```typescript
    import { QueryString } from "../../../../lib/location/query.string";
    import Cookies from "js-cookie";
    ```

    Add this import:
    ```typescript
    import { request } from "../../../../api/request/request";
    ```

    Keep the existing `PRODUCT_DOWNLOAD` import (still needed).

    Replace the `onClick` function:
    ```typescript
    const onClick = async () => {
      const response = await request(PRODUCT_DOWNLOAD);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'products.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };
    ```

    This sends the JWT in the Authorization header (added automatically by the `request` wrapper), not in the URL. The response is downloaded as a Blob and offered as a file download.

    The `request` function (at `front/src/api/request/request.ts`) already reads `Cookies.get('JWT')` and adds it as `Authorization: Bearer <token>` header. So no additional auth code is needed.
  </action>
  <verify>
    1. Check create.user.tsx has ROLE_VENDEUR in options: `grep -n "ROLE_VENDEUR" front/src/app-frontend/components/settings/users/create.user.tsx` — should match.
    2. Check create.user.tsx has NO ROLE_USER in options: `grep -n "ROLE_USER" front/src/app-frontend/components/settings/users/create.user.tsx` — should NOT match.
    3. Check export.items.tsx has NO JWT/bearer in URL: `grep -n "bearer\|Cookies\|QueryString" front/src/app-frontend/components/settings/items/export.items.tsx` — should NOT match.
    4. Check export.items.tsx uses request function: `grep -n "import.*request" front/src/app-frontend/components/settings/items/export.items.tsx` — should match.
    5. Check export.items.tsx uses Blob: `grep -n "blob\|createObjectURL" front/src/app-frontend/components/settings/items/export.items.tsx` — should match.
    6. Verify build still compiles: `cd /Users/abdellahi/Documents/POS/Pointe_de_Vente/front && npx vite build 2>&1 | tail -5` — should succeed.
  </verify>
  <done>
    - User create/edit form shows 3 role options: ROLE_VENDEUR, ROLE_MANAGER, ROLE_ADMIN
    - ROLE_USER is completely removed from the role dropdown
    - Role labels use t() for i18n support
    - Product export downloads via fetch+Blob with JWT in Authorization header
    - JWT is no longer exposed in URL query parameters
    - No reference to Cookies.get("JWT") or QueryString remains in export.items.tsx
    - Frontend builds without errors
  </done>
</task>

</tasks>

<verification>
After both tasks are complete:

1. **useHasRole hook**: File exists at `front/src/duck/auth/hooks/useHasRole.ts` with ROLE_HIERARCHY matching backend
2. **RequireRole component**: File exists at `front/src/app-common/components/auth/RequireRole.tsx`
3. **Route guards**: app.tsx has RequireRole on all 6 restricted routes (3 user + 3 report)
4. **Sidebar gating**: sidebar.tsx conditionally renders Reports (MANAGER+) and Users (ADMIN)
5. **Role options**: create.user.tsx has ROLE_VENDEUR/ROLE_MANAGER/ROLE_ADMIN, no ROLE_USER
6. **JWT fix**: export.items.tsx uses fetch+Blob, no JWT in URL
7. **Build**: `npx vite build` succeeds from front/ directory
</verification>

<success_criteria>
1. useHasRole hook mirrors ROLE_ADMIN > ROLE_MANAGER > ROLE_VENDEUR hierarchy
2. RequireRole component redirects unauthorized users to /dashboard (not /login)
3. User management routes (USERS, USERS_CREATE, USERS_EDIT) require ROLE_ADMIN
4. Report routes (REPORTS_SALES, REPORTS_PROFIT, REPORTS_DAILY) require ROLE_MANAGER
5. Sidebar hides Reports section from VENDEUR
6. Sidebar hides Administration/Users section from non-ADMIN
7. User form role dropdown shows ROLE_VENDEUR, ROLE_MANAGER, ROLE_ADMIN (no ROLE_USER)
8. Product export uses Authorization header, not URL parameter for JWT
9. Frontend project builds without TypeScript or bundler errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-rbac-and-security/01-02-SUMMARY.md`
</output>

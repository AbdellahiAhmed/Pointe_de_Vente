---
phase: 01-rbac-and-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - back/config/packages/security.yaml
  - back/src/Security/Voter/OrderVoter.php
  - back/src/Security/Voter/ProductVoter.php
  - back/src/Security/Voter/ReportVoter.php
  - back/src/Security/Voter/ClosingVoter.php
  - back/src/Security/Voter/UserManagementVoter.php
  - back/src/Security/Voter/CustomerVoter.php
  - back/src/Security/Voter/ExpenseVoter.php
  - back/src/Controller/Api/Admin/OrderController.php
  - back/src/Controller/Api/Admin/ProductController.php
  - back/src/Controller/Api/Admin/ReportController.php
  - back/src/Controller/Api/Admin/ClosingController.php
  - back/src/Controller/Api/Admin/UserController.php
  - back/src/Controller/Api/Admin/TerminalController.php
  - back/src/Controller/Api/Admin/CustomerController.php
  - back/src/Controller/Api/Admin/ExpenseController.php
  - back/src/Controller/Api/Admin/MediaController.php
  - back/migrations/VersionRbacRolesMigration.php
autonomous: true

must_haves:
  truths:
    - "ROLE_ADMIN > ROLE_MANAGER > ROLE_VENDEUR hierarchy is enforced by Symfony"
    - "A VENDEUR hitting /api/admin/report/* gets HTTP 403"
    - "A VENDEUR hitting /api/admin/user/* gets HTTP 403"
    - "A MANAGER hitting /api/admin/user/* gets HTTP 403"
    - "A MANAGER can access /api/admin/report/*, /api/admin/closing/*, /api/admin/product/*"
    - "A VENDEUR can access /api/admin/order/* and read /api/admin/product/keywords"
    - "All existing ROLE_USER users are migrated to ROLE_VENDEUR without lockout"
    - "IS_AUTHENTICATED_ANONYMOUSLY is replaced with PUBLIC_ACCESS"
  artifacts:
    - path: "back/config/packages/security.yaml"
      provides: "Role hierarchy and updated access control"
      contains: "role_hierarchy"
    - path: "back/src/Security/Voter/OrderVoter.php"
      provides: "Order access control - ROLE_VENDEUR minimum"
      min_lines: 20
    - path: "back/src/Security/Voter/ProductVoter.php"
      provides: "Product access control - VIEW for VENDEUR, MANAGE for MANAGER"
      min_lines: 25
    - path: "back/src/Security/Voter/ReportVoter.php"
      provides: "Report access control - ROLE_MANAGER minimum"
      min_lines: 20
    - path: "back/src/Security/Voter/ClosingVoter.php"
      provides: "Closing access control - ROLE_MANAGER minimum"
      min_lines: 20
    - path: "back/src/Security/Voter/UserManagementVoter.php"
      provides: "User/Terminal management - ROLE_ADMIN only"
      min_lines: 20
    - path: "back/src/Security/Voter/CustomerVoter.php"
      provides: "Customer management - ROLE_MANAGER minimum"
      min_lines: 20
    - path: "back/src/Security/Voter/ExpenseVoter.php"
      provides: "Expense management - ROLE_MANAGER minimum"
      min_lines: 20
  key_links:
    - from: "back/src/Controller/Api/Admin/ReportController.php"
      to: "back/src/Security/Voter/ReportVoter.php"
      via: "denyAccessUnlessGranted('REPORT_VIEW')"
      pattern: "denyAccessUnlessGranted.*REPORT_VIEW"
    - from: "back/src/Controller/Api/Admin/UserController.php"
      to: "back/src/Security/Voter/UserManagementVoter.php"
      via: "denyAccessUnlessGranted('USER_MANAGE')"
      pattern: "denyAccessUnlessGranted.*USER_MANAGE"
    - from: "back/src/Controller/Api/Admin/OrderController.php"
      to: "back/src/Security/Voter/OrderVoter.php"
      via: "denyAccessUnlessGranted('ORDER_MANAGE')"
      pattern: "denyAccessUnlessGranted.*ORDER_MANAGE"
---

<objective>
Backend RBAC: Configure Symfony role hierarchy, create Voter classes for all domains, wire denyAccessUnlessGranted into every admin controller, and migrate existing user roles.

Purpose: Establish the server-side security baseline so every API endpoint rejects unauthorized access with HTTP 403 before any new endpoints are added in future phases.
Output: 7 Voter classes, updated security.yaml, all 9 admin controllers gated, Doctrine migration for ROLE_USER -> ROLE_VENDEUR.
</objective>

<execution_context>
@/Users/abdellahi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abdellahi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-rbac-and-security/01-RESEARCH.md

@back/config/packages/security.yaml
@back/src/Entity/User.php
@back/src/Controller/Api/Admin/OrderController.php
@back/src/Controller/Api/Admin/ProductController.php
@back/src/Controller/Api/Admin/ReportController.php
@back/src/Controller/Api/Admin/ClosingController.php
@back/src/Controller/Api/Admin/UserController.php
@back/src/Controller/Api/Admin/TerminalController.php
@back/src/Controller/Api/Admin/CustomerController.php
@back/src/Controller/Api/Admin/ExpenseController.php
@back/src/Controller/Api/Admin/MediaController.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Security config + role hierarchy + Voter classes</name>
  <files>
    back/config/packages/security.yaml
    back/src/Security/Voter/OrderVoter.php
    back/src/Security/Voter/ProductVoter.php
    back/src/Security/Voter/ReportVoter.php
    back/src/Security/Voter/ClosingVoter.php
    back/src/Security/Voter/UserManagementVoter.php
    back/src/Security/Voter/CustomerVoter.php
    back/src/Security/Voter/ExpenseVoter.php
  </files>
  <action>
    **Satisfies: RBAC-06 (role hierarchy), RBAC-05 (backend enforcement foundation)**

    **1. Update `back/config/packages/security.yaml`:**

    Add role_hierarchy block under the `security:` key, BEFORE `providers:`:

    ```yaml
    role_hierarchy:
        ROLE_ADMIN: ROLE_MANAGER
        ROLE_MANAGER: ROLE_VENDEUR
    ```

    This creates the chain: ROLE_ADMIN > ROLE_MANAGER > ROLE_VENDEUR. Symfony resolves inheritance transitively, so ROLE_ADMIN inherits both ROLE_MANAGER and ROLE_VENDEUR.

    In the `access_control` section:
    - Replace ALL occurrences of `IS_AUTHENTICATED_ANONYMOUSLY` with `PUBLIC_ACCESS` (Symfony 5.4 deprecation).
    - Change `{ path: ^/api/admin, roles: [ ROLE_ADMIN, ROLE_USER ] }` to `{ path: ^/api/admin, roles: IS_AUTHENTICATED_FULLY }`. This ensures any authenticated user can reach the /api/admin prefix — fine-grained control is handled by Voters per controller action, not by the access_control firewall.

    Do NOT touch the firewalls, providers, or password_hashers sections — they are working correctly.

    **2. Create `back/src/Security/Voter/` directory and 7 Voter classes.**

    All Voters follow this pattern (Symfony 5.4 compatible):

    ```php
    <?php
    namespace App\Security\Voter;

    use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
    use Symfony\Component\Security\Core\Authorization\Voter\Voter;
    use Symfony\Component\Security\Core\Security;

    class ExampleVoter extends Voter
    {
        public const ATTRIBUTE = 'EXAMPLE_ATTRIBUTE';

        private Security $security;

        public function __construct(Security $security)
        {
            $this->security = $security;
        }

        protected function supports(string $attribute, $subject): bool
        {
            return in_array($attribute, [self::ATTRIBUTE]);
        }

        protected function voteOnAttribute(string $attribute, $subject, TokenInterface $token): bool
        {
            return $this->security->isGranted('MINIMUM_ROLE');
        }
    }
    ```

    Use constructor property promotion (PHP 8.0+) is fine — project already uses `private Security $security` syntax elsewhere.

    Create exactly these 7 Voter classes with these constants and minimum roles:

    | Voter Class | Constants | Minimum Role |
    |---|---|---|
    | `OrderVoter` | `MANAGE = 'ORDER_MANAGE'` | `ROLE_VENDEUR` |
    | `ProductVoter` | `VIEW = 'PRODUCT_VIEW'`, `MANAGE = 'PRODUCT_MANAGE'` | VIEW: `ROLE_VENDEUR`, MANAGE: `ROLE_MANAGER` |
    | `ReportVoter` | `VIEW = 'REPORT_VIEW'` | `ROLE_MANAGER` |
    | `ClosingVoter` | `MANAGE = 'CLOSING_MANAGE'` | `ROLE_MANAGER` |
    | `UserManagementVoter` | `MANAGE = 'USER_MANAGE'` | `ROLE_ADMIN` |
    | `CustomerVoter` | `MANAGE = 'CUSTOMER_MANAGE'` | `ROLE_MANAGER` |
    | `ExpenseVoter` | `MANAGE = 'EXPENSE_MANAGE'` | `ROLE_MANAGER` |

    **ProductVoter is special** — it needs a switch on $attribute:
    ```php
    protected function voteOnAttribute(string $attribute, $subject, TokenInterface $token): bool
    {
        return match ($attribute) {
            self::VIEW => $this->security->isGranted('ROLE_VENDEUR'),
            self::MANAGE => $this->security->isGranted('ROLE_MANAGER'),
            default => false,
        };
    }
    ```

    All other Voters have a single attribute and a single role check.

    Symfony's autowiring + autoconfigure will register these Voters automatically (no services.yaml entry needed — the project uses default Symfony autowiring).

    **3. Create Doctrine migration for ROLE_USER -> ROLE_VENDEUR.**

    Create file `back/migrations/Version20260217000001.php` (use a realistic timestamp):

    ```php
    <?php
    declare(strict_types=1);
    namespace DoctrineMigrations;

    use Doctrine\DBAL\Schema\Schema;
    use Doctrine\Migrations\AbstractMigration;

    final class Version20260217000001 extends AbstractMigration
    {
        public function getDescription(): string
        {
            return 'Migrate ROLE_USER to ROLE_VENDEUR in user_account.roles';
        }

        public function up(Schema $schema): void
        {
            // The roles column is a PHP serialized array (ORM type="array").
            // Replace the string literal inside the serialized data.
            $this->addSql("UPDATE user_account SET roles = REPLACE(roles, 'ROLE_USER', 'ROLE_VENDEUR') WHERE roles LIKE '%ROLE_USER%'");
        }

        public function down(Schema $schema): void
        {
            $this->addSql("UPDATE user_account SET roles = REPLACE(roles, 'ROLE_VENDEUR', 'ROLE_USER') WHERE roles LIKE '%ROLE_VENDEUR%'");
        }
    }
    ```

    CRITICAL: The User entity uses `@ORM\Column(type="array")` which stores PHP serialized arrays. The REPLACE works because it replaces the string literal `ROLE_USER` with `ROLE_VENDEUR` inside the serialized string. The string lengths are different (9 vs 13 chars) which BREAKS PHP serialization. So we must also fix the serialized string length.

    Actually, looking more carefully at the serialized format: `a:1:{i:0;s:9:"ROLE_USER";}` would become `a:1:{i:0;s:9:"ROLE_VENDEUR";}` with a simple REPLACE — but the `s:9` should be `s:13`. This would corrupt the data.

    **Better approach**: Use a two-step SQL:
    ```php
    public function up(Schema $schema): void
    {
        // For PHP serialized arrays, we need to handle the string length prefix.
        // ROLE_USER (9 chars) -> ROLE_VENDEUR (13 chars)
        // s:9:"ROLE_USER" -> s:13:"ROLE_VENDEUR"
        $this->addSql("UPDATE user_account SET roles = REPLACE(REPLACE(roles, 's:9:\"ROLE_USER\"', 's:13:\"ROLE_VENDEUR\"'), 'ROLE_USER', 'ROLE_VENDEUR') WHERE roles LIKE '%ROLE_USER%'");
    }
    ```

    Wait — the first REPLACE handles the serialized format correctly (s:9 -> s:13), and the second REPLACE is a safety net for any edge case. But after the first REPLACE succeeds, there should be no remaining `ROLE_USER` strings, so the second REPLACE is a no-op.

    Use this single SQL:
    ```php
    $this->addSql("UPDATE user_account SET roles = REPLACE(roles, 's:9:\"ROLE_USER\"', 's:13:\"ROLE_VENDEUR\"') WHERE roles LIKE '%ROLE_USER%'");
    ```

    And for down:
    ```php
    $this->addSql("UPDATE user_account SET roles = REPLACE(roles, 's:13:\"ROLE_VENDEUR\"', 's:9:\"ROLE_USER\"') WHERE roles LIKE '%ROLE_VENDEUR%'");
    ```

    IMPORTANT: Double-check the actual serialized format in the database. The roles field uses `type="array"` which PHP serializes as e.g. `a:2:{i:0;s:9:"ROLE_USER";i:1;s:10:"ROLE_ADMIN";}`. The REPLACE on `s:9:"ROLE_USER"` -> `s:13:"ROLE_VENDEUR"` is correct and preserves serialization integrity.
  </action>
  <verify>
    1. Run `cd /Users/abdellahi/Documents/POS/Pointe_de_Vente/back && php bin/console debug:config security role_hierarchy` — should show ROLE_ADMIN > ROLE_MANAGER > ROLE_VENDEUR chain.
    2. Run `php bin/console debug:container --tag=security.voter` — should list all 7 new Voter classes.
    3. Run `php bin/console lint:container` — no errors.
    4. Verify security.yaml parses: `php bin/console debug:config security access_control` — should show PUBLIC_ACCESS instead of IS_AUTHENTICATED_ANONYMOUSLY.
    5. Verify migration file exists and has valid PHP syntax: `php -l back/migrations/Version20260217000001.php`.
  </verify>
  <done>
    - security.yaml contains role_hierarchy with ROLE_ADMIN > ROLE_MANAGER > ROLE_VENDEUR
    - IS_AUTHENTICATED_ANONYMOUSLY replaced with PUBLIC_ACCESS everywhere
    - access_control for /api/admin uses IS_AUTHENTICATED_FULLY (not role-specific)
    - 7 Voter classes exist in back/src/Security/Voter/ with correct attribute constants and role checks
    - ProductVoter has two attributes (VIEW/MANAGE) with different role requirements
    - Doctrine migration exists to convert ROLE_USER -> ROLE_VENDEUR with correct serialization handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire denyAccessUnlessGranted into all admin controllers</name>
  <files>
    back/src/Controller/Api/Admin/OrderController.php
    back/src/Controller/Api/Admin/ProductController.php
    back/src/Controller/Api/Admin/ReportController.php
    back/src/Controller/Api/Admin/ClosingController.php
    back/src/Controller/Api/Admin/UserController.php
    back/src/Controller/Api/Admin/TerminalController.php
    back/src/Controller/Api/Admin/CustomerController.php
    back/src/Controller/Api/Admin/ExpenseController.php
    back/src/Controller/Api/Admin/MediaController.php
  </files>
  <action>
    **Satisfies: RBAC-01, RBAC-02, RBAC-03, RBAC-04, RBAC-05**

    Add `$this->denyAccessUnlessGranted(ATTRIBUTE)` as the FIRST line of every public action method in each controller. This call invokes the Symfony Voter system — if the current user lacks the required role, Symfony throws AccessDeniedException which returns HTTP 403.

    Import the Voter class at the top of each controller file for the constant reference.

    **Controller -> Voter Attribute Mapping:**

    **OrderController.php** — `use App\Security\Voter\OrderVoter;`
    Add to EVERY method (list, create, update, restore, dispatch, refund, delete):
    ```php
    $this->denyAccessUnlessGranted(OrderVoter::MANAGE);
    ```
    Place it as the very first line inside each method body, before any other code.

    **ProductController.php** — `use App\Security\Voter\ProductVoter;`
    - `keywords()` method: `$this->denyAccessUnlessGranted(ProductVoter::VIEW);` (VENDEUR can read)
    - `getQuantity()` method: `$this->denyAccessUnlessGranted(ProductVoter::VIEW);` (VENDEUR can read)
    - `download()` method: `$this->denyAccessUnlessGranted(ProductVoter::MANAGE);` (MANAGER+ for export)
    - `upload()` method: `$this->denyAccessUnlessGranted(ProductVoter::MANAGE);` (MANAGER+ for import)

    **ReportController.php** — `use App\Security\Voter\ReportVoter;`
    Add to ALL methods (sales, profit, daily):
    ```php
    $this->denyAccessUnlessGranted(ReportVoter::VIEW);
    ```

    **ClosingController.php** — `use App\Security\Voter\ClosingVoter;`
    Add to ALL methods (list, create, getOpened, getById, update, delete):
    ```php
    $this->denyAccessUnlessGranted(ClosingVoter::MANAGE);
    ```

    **UserController.php** — `use App\Security\Voter\UserManagementVoter;`
    Add to ALL methods (list, create, getById, update, delete):
    ```php
    $this->denyAccessUnlessGranted(UserManagementVoter::MANAGE);
    ```

    **TerminalController.php** — `use App\Security\Voter\UserManagementVoter;`
    Add to ALL methods (list, create, getById, update, delete):
    ```php
    $this->denyAccessUnlessGranted(UserManagementVoter::MANAGE);
    ```
    Note: Terminal management uses UserManagementVoter (same ADMIN-only restriction as user management).

    **CustomerController.php** — `use App\Security\Voter\CustomerVoter;`
    Add to ALL methods (list, create, addPayment, getById, update, delete):
    ```php
    $this->denyAccessUnlessGranted(CustomerVoter::MANAGE);
    ```

    **ExpenseController.php** — `use App\Security\Voter\ExpenseVoter;`
    Add to ALL methods (list, create, getById, update, delete):
    ```php
    $this->denyAccessUnlessGranted(ExpenseVoter::MANAGE);
    ```

    **MediaController.php** — `use App\Security\Voter\ProductVoter;`
    - `upload()` method: `$this->denyAccessUnlessGranted(ProductVoter::MANAGE);` (only MANAGER+ uploads media)
    - `content()` method: `$this->denyAccessUnlessGranted(ProductVoter::VIEW);` (VENDEUR can view media)

    **Summary of access matrix (for verification):**

    | Controller | Attribute | Min Role |
    |---|---|---|
    | OrderController (all) | ORDER_MANAGE | ROLE_VENDEUR |
    | ProductController (keywords, quantities) | PRODUCT_VIEW | ROLE_VENDEUR |
    | ProductController (export, import) | PRODUCT_MANAGE | ROLE_MANAGER |
    | ReportController (all) | REPORT_VIEW | ROLE_MANAGER |
    | ClosingController (all) | CLOSING_MANAGE | ROLE_MANAGER |
    | UserController (all) | USER_MANAGE | ROLE_ADMIN |
    | TerminalController (all) | USER_MANAGE | ROLE_ADMIN |
    | CustomerController (all) | CUSTOMER_MANAGE | ROLE_MANAGER |
    | ExpenseController (all) | EXPENSE_MANAGE | ROLE_MANAGER |
    | MediaController (upload) | PRODUCT_MANAGE | ROLE_MANAGER |
    | MediaController (content) | PRODUCT_VIEW | ROLE_VENDEUR |

    Do NOT change method signatures, return types, or any existing logic. Only ADD the denyAccessUnlessGranted call as the first line.
  </action>
  <verify>
    1. Run `php bin/console lint:container` from back/ directory — no errors.
    2. Grep for coverage: `grep -rn "denyAccessUnlessGranted" back/src/Controller/Api/Admin/` — every public action method in all 9 controllers should have exactly one call.
    3. Count: OrderController has 7 methods, ProductController has 4, ReportController has 3, ClosingController has 6, UserController has 5, TerminalController has 5, CustomerController has 6, ExpenseController has 5, MediaController has 2. Total: 43 denyAccessUnlessGranted calls.
    4. Verify no syntax errors: `php -l back/src/Controller/Api/Admin/*.php` — all files valid.
  </verify>
  <done>
    - All 9 admin controllers have denyAccessUnlessGranted as the first line of every public action
    - VENDEUR can only access Order endpoints and Product read endpoints (keywords, quantities)
    - MANAGER can access reports, closing, customers, expenses, product write (import/export), media upload
    - ADMIN can access user management and terminal management
    - No existing controller logic was changed — only authorization gate added
    - Container lint passes with no errors
  </done>
</task>

</tasks>

<verification>
After both tasks are complete:

1. **Role hierarchy**: `php bin/console debug:config security role_hierarchy` shows the 3-level chain
2. **Voter registration**: `php bin/console debug:container --tag=security.voter` lists all 7 voters
3. **No regressions**: `php bin/console lint:container` passes
4. **Access control**: `grep -c "denyAccessUnlessGranted" back/src/Controller/Api/Admin/*.php` shows counts per file matching expected totals
5. **Migration ready**: Migration file exists at back/migrations/Version20260217000001.php with valid syntax
6. **PUBLIC_ACCESS**: No remaining IS_AUTHENTICATED_ANONYMOUSLY in security.yaml
</verification>

<success_criteria>
1. security.yaml has role_hierarchy: ROLE_ADMIN > ROLE_MANAGER > ROLE_VENDEUR
2. 7 Voter classes exist in back/src/Security/Voter/ and are auto-registered
3. All 43 controller action methods have denyAccessUnlessGranted as first line
4. Doctrine migration exists to convert ROLE_USER -> ROLE_VENDEUR (serialization-safe)
5. IS_AUTHENTICATED_ANONYMOUSLY replaced with PUBLIC_ACCESS
6. access_control for /api/admin uses IS_AUTHENTICATED_FULLY
7. php bin/console lint:container passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-rbac-and-security/01-01-SUMMARY.md`
</output>

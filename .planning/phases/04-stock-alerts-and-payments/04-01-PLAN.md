---
phase: 04-stock-alerts-and-payments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - back/src/Entity/Payment.php
  - back/src/DataFixtures/PaymentTypes.php
  - back/migrations/VersionXXXXXXXXXXXXXX.php
  - back/src/Repository/ProductStoreRepository.php
  - back/src/Controller/Api/Admin/StockController.php
autonomous: true
requirements:
  - STOCK-01
  - STOCK-02
  - PAY-01
  - PAY-02

must_haves:
  truths:
    - "GET /api/admin/stock/alerts returns products whose quantity is below their reOrderLevel (or default 10)"
    - "GET /api/admin/stock/alerts?store=X filters results to a single store"
    - "Products with manageInventory=false never appear in stock alerts"
    - "Payment entity has a category column with values cash, mobile, or credit"
    - "Existing Payment rows have correct category values after migration (Bankily/Masrivi/Sedad -> mobile, Credit Client -> credit, Especes -> cash)"
  artifacts:
    - path: "back/src/Controller/Api/Admin/StockController.php"
      provides: "GET /api/admin/stock/alerts endpoint with RBAC gate"
      contains: "denyAccessUnlessGranted"
    - path: "back/src/Repository/ProductStoreRepository.php"
      provides: "findBelowReorderLevel() DQL query"
      contains: "COALESCE"
    - path: "back/src/Entity/Payment.php"
      provides: "category column with constants"
      contains: "CATEGORY_CASH"
    - path: "back/migrations/VersionXXXXXXXXXXXXXX.php"
      provides: "Schema migration adding category column + data backfill"
      contains: "ADD category"
    - path: "back/src/DataFixtures/PaymentTypes.php"
      provides: "Updated fixture with category values"
      contains: "category"
  key_links:
    - from: "back/src/Controller/Api/Admin/StockController.php"
      to: "back/src/Repository/ProductStoreRepository.php"
      via: "findBelowReorderLevel() method injection"
      pattern: "findBelowReorderLevel"
    - from: "back/src/Controller/Api/Admin/StockController.php"
      to: "back/src/Security/Voter/ProductVoter.php"
      via: "denyAccessUnlessGranted(ProductVoter::VIEW)"
      pattern: "ProductVoter::VIEW"
---

<objective>
Backend infrastructure for stock alerts and payment categorization.

Purpose: Provide the API endpoint that the POS badge and admin page will consume for low-stock product alerts, and add the `category` attribute to Payment so the Z-Report can group payments by cash/mobile/credit.

Output: Working `/api/admin/stock/alerts` endpoint with RBAC, `Payment.category` column with migration + data backfill, updated fixture.
</objective>

<execution_context>
@/Users/abdellahi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/abdellahi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-stock-alerts-and-payments/04-RESEARCH.md

Key reference files:
@back/src/Entity/Payment.php
@back/src/Entity/ProductStore.php
@back/src/DataFixtures/PaymentTypes.php
@back/src/Repository/ProductStoreRepository.php
@back/src/Controller/Api/Admin/ReportController.php (pattern reference for new controller)
@back/src/Security/Voter/ProductVoter.php (RBAC gate)
@back/src/Factory/Controller/ApiResponseFactory.php (response factory)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add category column to Payment entity with migration and fixture update</name>
  <files>
    back/src/Entity/Payment.php
    back/src/DataFixtures/PaymentTypes.php
    back/migrations/VersionXXXXXXXXXXXXXX.php
  </files>
  <action>
1. **Payment.php entity** — Add three new constants and a `category` property with getter/setter:

```php
const CATEGORY_CASH   = 'cash';
const CATEGORY_MOBILE = 'mobile';
const CATEGORY_CREDIT = 'credit';

/**
 * @ORM\Column(type="string", length=20, options={"default": "cash"})
 * @Gedmo\Versioned()
 * @Groups({"payment.read", "order.read", "customer.read"})
 */
private string $category = self::CATEGORY_CASH;

public function getCategory(): string
{
    return $this->category;
}

public function setCategory(string $category): self
{
    $this->category = $category;
    return $this;
}
```

Place the constants after the existing `PAYMENT_TYPE_*` constants. Place the property after `$canHaveChangeDue`. Include `@Groups` with `"payment.read"`, `"order.read"`, and `"customer.read"` — matching the same groups as `name` and `type` for API Platform serialization consistency.

2. **Generate the Doctrine migration** inside the Docker container:

```bash
docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console doctrine:migrations:diff --no-interaction
```

This will create a migration file in `back/migrations/`. Then **manually edit** the generated migration to add data backfill UPDATE statements **after** the ALTER TABLE:

```php
$this->addSql("UPDATE payment SET category = 'mobile' WHERE type IN ('bankily', 'masrivi', 'sedad', 'credit card')");
$this->addSql("UPDATE payment SET category = 'credit' WHERE type = 'credit'");
```

The default `'cash'` on the column handles Especes rows automatically.

**CRITICAL:** The data migration is essential. Without it, all existing Payment rows default to `'cash'`, which would make the Z-Report show everything as cash.

3. **Run the migration** inside Docker:

```bash
docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console doctrine:migrations:migrate --no-interaction
```

4. **PaymentTypes.php fixture** — Update the `$types` array to include `'category'` for each entry:

```php
$types = [
    ['name' => 'Especes',        'type' => 'cash',        'category' => 'cash',   'changeDue' => true],
    ['name' => 'Carte Bancaire', 'type' => 'credit card',  'category' => 'mobile', 'changeDue' => false],
    ['name' => 'Credit Client',  'type' => 'credit',       'category' => 'credit', 'changeDue' => false],
    ['name' => 'Bankily',        'type' => 'bankily',      'category' => 'mobile', 'changeDue' => false],
    ['name' => 'Masrivi',        'type' => 'masrivi',      'category' => 'mobile', 'changeDue' => false],
    ['name' => 'Sedad',          'type' => 'sedad',        'category' => 'mobile', 'changeDue' => false],
];
```

And add `$paymentType->setCategory($t['category']);` inside the foreach loop, after `setCanHaveChangeDue`.

**IMPORTANT:** Name the field `category` NOT `type` — the existing `type` field is used in `sale.inline.tsx` for credit-disable logic (`pt.type === "credit"`). Collision would break payment button behavior.
  </action>
  <verify>
1. Run migration status: `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console doctrine:migrations:status` — should show no pending migrations.
2. Verify the column exists: `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console doctrine:schema:validate` — should report schema is in sync.
3. Verify data backfill with a quick DQL query or raw SQL: `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console doctrine:query:sql "SELECT name, type, category FROM payment"` — Bankily/Masrivi/Sedad should show `mobile`, Credit Client should show `credit`, Especes should show `cash`.
  </verify>
  <done>Payment entity has a `category` VARCHAR(20) column with constants CATEGORY_CASH/CATEGORY_MOBILE/CATEGORY_CREDIT. Migration is applied. All existing Payment rows have the correct category. Fixture creates new Payment entries with the correct category.</done>
</task>

<task type="auto">
  <name>Task 2: Create stock alerts endpoint with repository query and RBAC gate</name>
  <files>
    back/src/Repository/ProductStoreRepository.php
    back/src/Controller/Api/Admin/StockController.php
  </files>
  <action>
1. **ProductStoreRepository.php** — Add the `findBelowReorderLevel` method. Replace the commented-out example methods with this real implementation:

```php
/**
 * @return ProductStore[] Products where quantity is below their reorder threshold
 */
public function findBelowReorderLevel(?int $storeId = null): array
{
    $qb = $this->createQueryBuilder('ps')
        ->join('ps.product', 'p')
        ->join('ps.store', 's')
        ->addSelect('p', 's')
        ->andWhere('p.manageInventory = true')
        ->andWhere('ps.quantity < COALESCE(ps.reOrderLevel, 10)');

    if ($storeId !== null) {
        $qb->andWhere('s.id = :store')
           ->setParameter('store', $storeId);
    }

    $qb->orderBy('ps.quantity', 'ASC');

    return $qb->getQuery()->getResult();
}
```

**CRITICAL:** Include `p.manageInventory = true` to avoid false alerts on unmanaged products. Use `COALESCE(ps.reOrderLevel, 10)` to apply default threshold of 10 when `reOrderLevel` is NULL (per STOCK-01).

2. **StockController.php** — Create a new controller at `back/src/Controller/Api/Admin/StockController.php` following the existing `ReportController` pattern:

```php
<?php

namespace App\Controller\Api\Admin;

use App\Entity\ProductStore;
use App\Factory\Controller\ApiResponseFactory;
use App\Repository\ProductStoreRepository;
use App\Security\Voter\ProductVoter;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

/**
 * @Route("/admin/stock", name="admin_stock_")
 */
class StockController extends AbstractController
{
    /**
     * @Route("/alerts", methods={"GET"}, name="alerts")
     */
    public function alerts(
        Request $request,
        ProductStoreRepository $repo,
        ApiResponseFactory $responseFactory
    ): Response {
        $this->denyAccessUnlessGranted(ProductVoter::VIEW);

        $storeId = $request->query->getInt('store') ?: null;
        $items = $repo->findBelowReorderLevel($storeId);

        $data = array_map(static fn(ProductStore $ps) => [
            'productId'    => $ps->getProduct()->getId(),
            'productName'  => $ps->getProduct()->getName(),
            'storeId'      => $ps->getStore()->getId(),
            'storeName'    => $ps->getStore()->getName(),
            'quantity'     => (float) $ps->getQuantity(),
            'reOrderLevel' => (float) ($ps->getReOrderLevel() ?? 10),
        ], $items);

        return $responseFactory->json([
            'list'  => $data,
            'count' => count($data),
        ]);
    }
}
```

**CRITICAL:** Return a manual DTO array, NOT raw ProductStore entities. The `ApiResponseFactory::json()` uses the Symfony serializer which will hit circular reference errors (ProductStore -> Product -> ProductStore) if raw entities are serialized. The manual array avoids this entirely.

Uses `ProductVoter::VIEW` which grants access to `ROLE_VENDEUR` (cashier role) — so the POS badge can hit this endpoint. Managers also have this permission via Symfony role hierarchy.
  </action>
  <verify>
1. Clear the Symfony cache: `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console cache:clear`
2. Verify route exists: `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console debug:router | grep stock` — should show `admin_stock_alerts GET /admin/stock/alerts`
3. Test the endpoint manually (requires a valid JWT token for a user with at least ROLE_VENDEUR): `curl -H "Authorization: Bearer <JWT>" http://localhost/api/admin/stock/alerts` — should return `{"list": [...], "count": N}` with no 500 errors.
4. Test store filter: `curl -H "Authorization: Bearer <JWT>" http://localhost/api/admin/stock/alerts?store=1` — should return filtered results.
  </verify>
  <done>GET /api/admin/stock/alerts returns a JSON object with `list` (array of product alert DTOs with productId, productName, storeId, storeName, quantity, reOrderLevel) and `count`. The endpoint is gated by ProductVoter::VIEW (ROLE_VENDEUR+). Products with manageInventory=false are excluded. Default threshold is 10 when reOrderLevel is NULL. Store filter works via `?store=X` query parameter.</done>
</task>

</tasks>

<verification>
1. `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console doctrine:schema:validate` — schema is in sync with entity metadata
2. `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console debug:router | grep stock` — route `admin_stock_alerts` is registered
3. `docker exec dev-php-polymer php /var/www/html/polymer/back/bin/console doctrine:query:sql "SELECT name, type, category FROM payment"` — all rows have correct category
4. No 500 errors when hitting `/api/admin/stock/alerts` with a valid JWT
</verification>

<success_criteria>
- Payment.category column exists with correct values for all existing rows
- Stock alerts endpoint returns correct DTO array with RBAC protection
- Products with manageInventory=false are excluded from alerts
- Default threshold of 10 applies when reOrderLevel is NULL
- Store filter works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/04-stock-alerts-and-payments/04-01-SUMMARY.md`
</output>
